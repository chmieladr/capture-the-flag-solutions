# Hash/Clash
Difficulty: Hard

### 1. Learn what even HashClash is
Have a look at the title.
It clearly mentions the name **HashClash**.
On one hand, it might suggest that we might require some "clashing" of hashes.
On the other hand, you can quickly search it up and find out
that it's a name of a tool available on GitHub (for this exact purpose by the way).

### 2. Look at the provided server's code and functionality
After connecting to the nc server, you can see that it lets you provide Python code encoded in `base64`.
Then the server decodes that code,
checks if there are any "blacklisted" functions, and if not, it saves the MD5 hash of that code and marks it as safe.
After sending it for the second time, it actually runs that code and returns the output.
However, as you likely guessed, simple commands like `open` or `os`,
to just open the `flag` file and print it, were banlisted.

### 3. Think about the possible ways to exploit it
Since it heavily relies on hashes, that's where the main vulnerability lies.
You can't just send a code that would return the flag, but you can try to find a hash collision.
You can then prepare two very similar but also very different programs.
One of them will be safe and the other one will be malicious.
You send the safe one first, then the malicious one.
The server will run the safe one, save the hash and then run the malicious one, thinking it's the same code.

> **Note:** Another important realization is the fact that audithooks used in the server's code don't check
> if the banlisted functions are mentioned in the file overall.
> They only look for the execution of these functions.
> This will be exploited later in very specific way.

### 4. Prepare the code
Well... the explanation provided above sounds easier said than done.
You need to find a collision for the MD5 hash.
It's not that easy, but it's possible.
However, that's where the HashClash tool comes in handy.
Or similar tools to that one...
I've personally later discovered `fastcoll` (https://github.com/brimstone/fastcoll)
which is a simpler tool that contains the exact functionality I needed.
It lets me generate two files with the same MD5 hash with one special twist.
I can also provide a file containing a prefix that each of the files will begin with.
That's exactly what I needed.

### 5. Find out even more useful info about MD5 exploits
Later research led me to even more useful information. Basically, it's totally possible to:
1. Prepare any code I want that can be used as a prefix.
2. Generate two files with the same MD5 hash using one of the mentioned tools.
Although, we have to keep in mind that this part generated by the tool is a total gibberish.
But that's not a problem, as long as the prefix and suffix are correct.
We can close this entire thing within ''' block.
3. Concatenate them with any suffix I want (which can be another part of the code).
As long as the suffix is the same for both files, the MD5 hash of both files will also be identical.
4. It's preferred to use commands like `cat` to concatenate them,
as manual copy-pasting might lead to some slight differences that won't necessarily be visible
due to how encoding works (especially with random generated non-ASCII characters).

> **Note:** Each of these blocks needs to be exactly 64 bytes long (or a multiple of 64 bytes).
> They also have to be a valid Python code as entirety.
> The length of particular parts can be adjusted using comments etc. or slightly modifying the syntax.

### 6. Prepare the final code
While preparing the final code, there are still a couple important things worth mentioning:
1. The prefix needs to start with the given tag that is specific for you. It won't work without that tag.
2. "Gibberish" coming from the tool can be assigned to a variable without any problems.
We'll assign it in the prefix part and exploit later in the suffix part.
3. The suffix part needs to contain the code that will return the flag.
However, we'll additionally cover that with simple `if` statement
that will look for some very slight difference in our variable containing the gibberish.
In my case `collision.count("=")%2` was enough.

> Since I took me a while, before I discovered all of that and actually received the flag,
> I prepared a simple `collide.sh` script that could execute `fastcoll` for me and concatenate the files right after.

### 7. Executed commands
a. For `fastcoll` execution:
```bash
git clone https://github.com/brimstone/fastcoll.git
cd fastcoll
# copied the prefix file to the directory
# prepared the collide.sh script
chmod +x collide.sh
sudo ./collide.sh
```
b. On the server:
```bash
cocojumbo@localhost:~> nc *******.pw.edu.pl 10411
[*] Hello on our server!
[*] Your secret is '# ADBFE529'
[?] Provide a Base64-encoded Python code:
IyBBREJGRTUyOQojIHF3ZXJ0eXVpb3Bhc2RmZ2hqa2x6eGN2Ym5tcXdlcnR5dTEKY29sbGlzaW9uID0gIiIiCnJGZ893vOqK2aSlBKTZ7dHg0SRFU6gG8kLaOLVHDLD7IuXZvs6ExzNH3kDkz4OCsMuhbMd52s067FOV943M9T2SHV0exkh+ERl7EK9j3P8KpYEs+RY4Ey98++9fW02twRxssSoShqK+J5pnmTt3XSn7KxMp8LbINTRyvz29Kx8MIiIiCmlmIGNvbGxpc2lvbi5jb3VudCgiPSIpJTI6IHByaW50KG9wZW4oImZsYWciLCAicmIiKS5yZWFkKCkpCg==
[ ] Veryfing if the code is safe to run...
[+] Code is safe. Remember the hash digest.
[?] Provide a Base64-encoded Python code:
IyBBREJGRTUyOQojIHF3ZXJ0eXVpb3Bhc2RmZ2hqa2x6eGN2Ym5tcXdlcnR5dTEKY29sbGlzaW9uID0gIiIiCnJGZ893vOqK2aSlBKTZ7dHg0STFU6gG8kLaOLVHDLD7IuXZvs6ExzNH3kDkzwOCsMuhbMd52s067FOVd43M9T2SHV0exkh+ERl7EK9j3P8KpYEseRY4Ey98++9fW02twRxssSoShqK+J5pnmTv3XSn7KxMp8LbINTRyv729Kx8MIiIiCmlmIGNvbGxpc2lvbi5jb3VudCgiPSIpJTI6IHByaW50KG9wZW4oImZsYWciLCAicmIiKS5yZWFkKCkpCg==
b'PW{M4rcSt3ven5_iS_tHe_GuY2b6c72dd9a805124}\n'
[ ] Running an already verified code...
[*] Done. Exited with return code: 0
```

My final code can be seen in `safe.py` and `malicious.py` files.

### 8. Result
`safe.py`'s base64: \
`IyBBREJGRTUyOQojIHF3ZXJ0eXVpb3Bhc2RmZ2hqa2x6eGN2Ym5tcXdlcnR5dTEKY29sbGlzaW9uID0gIiIiCnJGZ893vOqK2aSlBKTZ7dHg0SRFU6gG8kLaOLVHDLD7IuXZvs6ExzNH3kDkz4OCsMuhbMd52s067FOV943M9T2SHV0exkh+ERl7EK9j3P8KpYEs+RY4Ey98++9fW02twRxssSoShqK+J5pnmTt3XSn7KxMp8LbINTRyvz29Kx8MIiIiCmlmIGNvbGxpc2lvbi5jb3VudCgiPSIpJTI6IHByaW50KG9wZW4oImZsYWciLCAicmIiKS5yZWFkKCkpCg==`

`malicious.py`'s base64: \
`IyBBREJGRTUyOQojIHF3ZXJ0eXVpb3Bhc2RmZ2hqa2x6eGN2Ym5tcXdlcnR5dTEKY29sbGlzaW9uID0gIiIiCnJGZ893vOqK2aSlBKTZ7dHg0STFU6gG8kLaOLVHDLD7IuXZvs6ExzNH3kDkzwOCsMuhbMd52s067FOVd43M9T2SHV0exkh+ERl7EK9j3P8KpYEseRY4Ey98++9fW02twRxssSoShqK+J5pnmTv3XSn7KxMp8LbINTRyv729Kx8MIiIiCmlmIGNvbGxpc2lvbi5jb3VudCgiPSIpJTI6IHByaW50KG9wZW4oImZsYWciLCAicmIiKS5yZWFkKCkpCg==`

**Output:** `b'PW{M4rcSt3ven5_iS_tHe_GuY2b6c72dd9a805124}\n'`\
**Flag:** `PW{M4rcSt3ven5_iS_tHe_GuY2b6c72dd9a805124}`